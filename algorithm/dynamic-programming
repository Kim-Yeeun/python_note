
#-------------------------------------------------------------------------------------------
# 다이나믹 프로그래밍(동적 계획법)
# 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
# 이미 계산된 결과는 별도 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
# 1. 최적 부분 구조 2. 중복되는 부분 문제 /  두가지 조건을 만족할 때 사용할 수 있다.
# 탑다운(메모이제이션) 방식 - 하향식, 보텀업 방식 - 상향식
# 다이나믹 프로그래밍의 전형적인 형태는 보텀업 방식(반복문 사용) - 결과 저장용 리스트는 DP 테이블이라고 부른다.

#-------------------------------------------------------------------------------------------
# 피보나치 수열

def fibo(x):
  if x == 1 or x == 2:
    return 1
  return fibo(x-1) + fibo(x-2)

print(fibo(4))

#-------------------------------------------------------------------------------------------
# 탑다운 방식 - 메모이제이션(캐싱)
# 한 번 계산한 결과를 메모리 공간에 메모하는 기법
# 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.

d = [0] * 100

def fibo(x):
  if x == 1 or x == 2:
    return 1

  if d[x] != 0: # 이미 계산된 적 있는 문제라면 그대로 다시 반환
    return d[x]

  d[x] = fibo(x-1) + fibo(x-2)
  return d[x]

print(fibo(99)) # 218922995834555169026

#-------------------------------------------------------------------------------------------
# 보텀업 방식
# 작은 문제부터 먼저 해결한 후 이를 조합해서 앞으로의 큰 문제를 차례대로 구해 나간다.

d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
  d[i] = d[i-1] + d[i-2]

print(d[n]) # 218922995834555169026

