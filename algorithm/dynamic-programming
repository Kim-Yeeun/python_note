
#-------------------------------------------------------------------------------------------
# 다이나믹 프로그래밍(동적 계획법)
# 메모리를 적절히 사용하여 수행 시간 효율성을 비약적으로 향상시키는 방법
# 이미 계산된 결과는 별도 메모리 영역에 저장하여 다시 계산하지 않도록 한다.
# 최적 부분 구조, 중복되는 부분 문제 /  두가지 조건을 만족할 때 사용할 수 있다.
# * 다이나믹 프로그래밍 vs 분할 정복(퀵 정렬) -> 부분 문제의 중복
# 1. 그리디, 구현, 완전 탐색 등의 아이디어로 문제를 해결할 수 있는지 검토
# 2. 재귀 함수로 비효율적인 완전 탐색 프로그램을 작성한 뒤 작은 문제에서 구한 답이 큰 문제에서 그대로 사용될 수 있으면 코드를 개선하는 방법 사용
# 3. 일반적인 코딩 테스트 수준에서는 기본 유형의 다이나믹 프로그래밍 문제가 출제

#-------------------------------------------------------------------------------------------
# 피보나치 수열

def fibo(x):
  if x == 1 or x == 2:
    return 1
  return fibo(x-1) + fibo(x-2)

print(fibo(4))

#-------------------------------------------------------------------------------------------
# 탑다운 방식 - 메모이제이션(캐싱)- 하향식
# 한 번 계산한 결과를 메모리 공간에 메모하는 기법
# 같은 문제를 다시 호출하면 메모했던 결과를 그대로 가져온다.
# * 시간 복잡도 분석 : O(N)

d = [0] * 100

def fibo(x):
  if x == 1 or x == 2:
    return 1

  if d[x] != 0: # 이미 계산된 적 있는 문제라면 그대로 다시 반환
    return d[x]

  d[x] = fibo(x-1) + fibo(x-2)
  return d[x]

print(fibo(99)) # 218922995834555169026

#-------------------------------------------------------------------------------------------
# 보텀업 방식 - 상향식
# 작은 문제부터 먼저 해결한 후 이를 조합해서 앞으로의 큰 문제를 차례대로 구해 나간다.
# 다이나믹 프로그래밍의 전형적인 형태 - 반복문 사용
# 결과 저장용 리스트는 DP 테이블이라고 부른다.

d = [0] * 100

d[1] = 1
d[2] = 1
n = 99

for i in range(3, n+1):
  d[i] = d[i-1] + d[i-2]

print(d[n]) # 218922995834555169026

#-------------------------------------------------------------------------------------------
# 개미 전사 문제
# 메뚜기 마을에는 여러 개의 일직선으로 이어져 있는 식량창고가 존재
# 각 식량창고에는 정해진 수의 식량을 저장, 개미 전사는 이를 선택적으로 약탈하여 식량을 빼앗을 예정
# 일직선상의 식량창고 중 서로 인접한 식량창고가 공격받으면 바로 알아챌 수 있다.
# 식량창고 N개에 대한 정보가 주어졌을 때 얻을 수 있는 식량의 최댓값
# -> ai = i번째 식량창고까지의 최적의 해(얻을 수 있는 식량의 최댓값)
# -> ki = i번째 식향창고에 있는 식량의 양
# -> 점화식 = ai = max(a(i-1), a(i-2) + ki)
# -> 한 칸 이상 떨어진 식량창고는 항상 털 수 있으므로 (i - 3)번째 이하는 고려할 필요가 없다.

n = int(input())
k = list(map(int, input().split()))

d = [0] * 100

d[0] = k[0]
d[1] = max(k[0], k[1])
for i in range(2, n):
  d[i] = max(d[i-1], d[i-2] + k[i])

print(d[n-1])

#-------------------------------------------------------------------------------------------
# 1로 만들기 문제
# 정수 X가 주어졌을 때
# 1. X가 5로 나누어 떨어지면, 5로 나눈다.
# 2. X가 3으로 나누어 떨어지면, 3으로 나눈다.
# 3. X가 2로 나누어 떨어지면, 2로 나눈다.
# 4. X에서 1을 뺀다.
# 위의 연산 4개를 적절히 사용하여 값을 1로 만들고자 할 때, 연산을 사용하는 횟수의 최솟값

x = int(input())

d = [0] * 30000

for i in range(2, x+1):
  d[i] = d[i-1] + 1

  if i % 2 == 0:
    d[i] = min(d[i], d[i//2] + 1)
  if i % 3 == 0:
    d[i] = min(d[i], d[i//3] + 1)
  if i % 5 == 0:
    d[i] = min(d[i], d[i//5] + 1)

print(d[x])

#-------------------------------------------------------------------------------------------
# 효율적인 화폐 구성 문제
# N가지 화폐 종류, M원을 만들기 위한 최소한의 화폐 개수
# -> ai = 금액 i를 만들 수 있는 최소한의 화폐 개수
# -> k = 각 화폐의 단위
# -> 점화식 = 각 화폐 단위 k를 하나씩 확인하며 a(i-k)를 만드는 방법이 존재하는 경우 ai = min(ai, a(i-k)+1), 존재하지 않는 경우 ai = INF

n, m = map(int, input().split()) # 3 7

money = []
for i in range(n): # 2 3 5
  money.append(int(input()))

d = [10001] * (m+1)

d[0] = 0
for i in range(n):
  for j in range(money[i], m+1):
    if d[j - money[i]] != 10001:
      d[j] = min(d[j], d[j - money[i]] + 1)

if d[m] == 10001:
  print(-1)
else:
  print(d[m]) # 2

#-------------------------------------------------------------------------------------------
# 금광 문제
# n X m 크기의 금광, 1 X 1 크기의 칸으로 나누어져 있으며 각 칸은 특정 크기의 금이 들어있다.
# 첫 열의 어느 행에서든 출발 가능, 이후 m - 1번에 걸쳐 매번 오른쪽 위, 오른쪽, 오른쪽 아래 3가지 중 하나의 위치로 이동
# 채굴자가 얻을 수 있는 금의 최대 크기
# -> array[i][j] = i행 j열에 존재하는 금의 양
# -> dp[i][j] = i행 j열까지의 최적의 해(얻을 수 있는 금의 최댓값)
# -> 점화식 = dp[i][j] = array[i][j] + max(dp[i-1][j-1], dp[i][j-1], dp[i+1][j-1])
# -> 테이블에 접근할 때마다 리스트의 범위를 벗어나지 않는지 체크

for _ in range(int(input())):
  n, m = map(int, input().split())
  array = list(map(int, input().split()))

  dp = []
  idx = 0
  for i in range(n):
    dp.append(array[idx:idx+m])
    idx += m
  
  for j in range(1, m):
    for i in range(n):
      if i == 0:
        left_up = 0
      else:
        left_up = dp[i-1][j-1]
      if i == n - 1:
        left_down = 0
      else:
        left_down = dp[i+1][j-1]
      left = dp[i][j-1]
      dp[i][j] = dp[i][j] + max(left_up, left_down, left)

  result = 0
  for i in range(n):
    result = max(result, dp[i][m-1])
  print(result)

#-------------------------------------------------------------------------------------------
# 병사 배치하기 문제
# N명의 병사가 무작위로 나열, 각 병사는 특정 값의 전투력을 보유
# 병사를 배치할 때는 전투력이 높은 병사가 앞쪽에 오도록 내림차순으로 배치, 앞 병사의 전투력이 뒤 병사의 전투력보다 높아야 한다.
# 특정 위치에 있는 병사를 열외시키는 방법을 이용, 남아 있는 병사의 수가 최대
# -> 가장 긴 증가하는 부분 수열, 가장 긴 감소하는 부분 수열을 찾는 문제
# -> D[i] = array[i]를 마지막 원소로 가지는 부분 수열의 최대 길이
# -> 점화식 = D[i] = max(D[i], D[j]+1) if array[j] < array[i] (0 <= j < i)

n = int(input())
s = list(map(int, input().split()))

s.reverse()

dp = [1] * n

for i in range(1, n):
  for j in range(0, i):
    if s[j] < s[i]:
      dp[i] = max(dp[i], dp[j]+1)

print(n - max(dp))



