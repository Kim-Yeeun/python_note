
#-----------------------------------------------------------------------------------------------
# 소수
# 1보다 큰 자연수 중에서 1과 자기 자신을 제외한 자연수로는 나누어 떨어지지 않는 자연수
# * 시간 복잡도 분석: 2부터 X-1까지의 모든 자연수에 대해 연산을 수행 -> O(X)

def is_prime_number(x):
  for i in range(2, x):
    if x % i == 0:
      return False
  return True

print(is_prime_number(4))
print(is_prime_number(7))

#-----------------------------------------------------------------------------------------------
# 약수
# 모든 약수가 가운데 약수를 기준으로 곱셈 연산에 대해 대칭
# 특정 자연수의 모든 약수를 찾을 때 가운데 약수(제곱근)까지 확인
# * 시간 복잡도 분석 : O(N^1/2)

# 개션된 소수 판별 알고리즘
import math

def is_prime_number(x):
  for i in range(2, int(math.sqrt(x))+1):
    if x % i == 0:
      return False
  return True

print(is_prime_number(4))
print(is_prime_number(7))

#-----------------------------------------------------------------------------------------------
# 에라토스테네스의 체
# 다수의 자연수에 대해 소수 여부를 판별할 때 사용
# N보다 작거나 같은 모든 소수를 찾을 때 사용
# 1. 2부터 N까지의 모든 자연수를 나열
# 2. 남은 수 중에서 아직 처리하지 않은 가장 작은 수 i를 찾는다.
# 3. 남은 수 중에서 i의 배수를 모두 제거(i 제외)
# 더 이상 반복할 수 없을 때까지 2, 3번 과정 반복
# * 시간 복잡도 분석 : 선형 시간에 가까울 정도로 매우 빠르다. -> O(NloglogN), 메모리가 많이 필요

import math

n = 1000
array = [True for i in range(n+1)]

for i in range(2, int(math.sqrt(n))+1):
  if array[i] == True:
    j = 2
    while i*j <= n:
      array[i*j] = False
      j += 1

for i in range(2, n+1):
  if array[i]:
    print(i, end=' ')

#-----------------------------------------------------------------------------------------------
# 투 포인터
# 리스트에 순차적으로 접근해야 할 때 두 개의 점의 위치를 기록하면서 처리
# 리스트의 데이터에 순차적으로 접근해야 할 때는 시작점과 끝점 2개의 점으로 접근할 데이터의 범위를 표현

#-----------------------------------------------------------------------------------------------
# 특정 합을 가지는 부분 연속 수열 찾기 문제
# N개 자연수로 구성된 수열, 합이 M인 부분 연속 수열의 개수, 수행 시간 제한은 O(N)
# 1. 시작점과 끝점이 첫번째 원소의 인덱스를 가리키도록 한다.
# 2. 현재 부분 합이 M과 같다면 카운트
# 3. 현재 부분 합이 M보다 작다면 끝점을 1 증가
# 4. 현재 부분 합이 M보다 크거나 같다면 시작점을 1 증가
# 5. 모든 경우를 확인할 때까지 2~4번 과정을 반복

n = int(input())
m = int(input())
data = [1, 2, 3, 2, 5]

count = 0
interval_sum = 0
end = 0

for start in range(n):
  while interval_sum < m and end < n:
    interval_sum += data[end]
    end += 1

  if interval_sum == m:
    count += 1
  interval_sum -= data[start]

print(count)

#-----------------------------------------------------------------------------------------------
# 구간 합 문제
# 연속적으로 나열된 N개 수가 있을 때 특정 구간의 모든 수를 합한 값을 계산
# N개 정수로 구성된 수열, M개 쿼리 정보
# 각 쿼리는 left, right로 구성, 각 쿼리에 대해 [left,right] 구간에 포함된 데이터들의 합을 출력
# 수행 시간 제한은 O(N+M)

# 접두사 합 : 배열의 맨 앞부터 특정 위치까지의 합을 미리 구해 놓은 것
# N개 수 위치 각각에 대해 접두사 합을 계산하여 P에 저장
# 매 M개 쿼리 정보를 확인할 때 구간 합은 P[right]-P[left-1]

n = 5
data = [10, 20, 30, 40, 50]

sum_value = 0
prefix_sum = [0]
for i in data:
  sum_value += i
  prefix_sum.append(sum_value)

left = 3
right = 4
print(prefix_sum[right] - prefix_sum[left-1])



