
#------------------------------------------
# 거스름돈 문제
# 500, 100, 50, 10원의 동전이 무한히 존재
# 거슬러 줄 돈이 N원일 때 거슬러 줄 동전의 최소 개수 구하기
# -> 최적의 해를 구하기 위해서는 가장 큰 화폐 단위부터 돈을 거슬러준다.
# * 정당성 분석 : 동전 중에서 큰 단위가 항상 작은 단위의 배수이므로 작은 단위의 동전들을 종합해 다른 해가 나올 수 없다. 
# * 시간복잡도 분석 : 화폐 종류가 K일 때 O(K)

n = 1260
count = 0

array = [500, 100, 50, 10]

for coin in array:
  count += n // coin
  n %= coin

print(count) # 6

#------------------------------------------
# 1이 될 때까지 문제
# 어떠한 수 N이 1이 될 때까지
# 1. N에서 1을 뺀다.
# 2. N을 K로 나눈다.
# 위의 두 과정 중 하나를 골라 반복적으로 수행해야하는 최소 횟수 구하기
# -> 주어진 N에 대하여 최대한 많이 나누기를 수행
# * 정당성 분석 : 나누기를 하는 것이 수를 기하급수적으로 빠르게 줄일 수 있다.

n, k = map(int, input().split())
count = 0

while n != 1:
  if n % k == 0:
    n /= k
    count += 1
  else:
    n -= k
    count += 1

print(count)

# 예시

n, k = map(int, input().split())
count = 0

while True:
  target = (n // k) * k # n이 k로 나누어 떨어지지 않을 때 가장 가까운 k로 나누어 떨어지는 수
  count += (n - target) # 빼기 연산 수행 횟수 더하기
  n = target
  
  if n < k:
    break
    
  count += 1
  n //= k
    
count += (n - 1) # 마지막으로 남은 수에 대하여 1씩 빼기
print(count)
